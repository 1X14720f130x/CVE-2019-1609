# CVE-2019-1609
Statis analysis of the RTCore64 associated with Micro-Star MSI Afterburner version 4.6.2.15658 +  POC
# Introduction 

The `RTCore` driver typically refers to a component associated with `Micro-Star MSI Afterburner` version `4.6.2.15658`, a popular **utility** used for **overclocking** and **monitoring graphics cards**.

`RTCore` is a kernel-mode driver that interacts with the GPU. 


# `Functions` 

## `DriverEntry (sub_1AC0)`

The `RTCore` driver initializes a Device object using the `IoCreateDevice` function, assigning the name "`RTCore64`" to the device.  

The device type is set as `FILE_DEVICE_UNKNOWN` and does not contain any specific characteristics.

Additionally, the driver creates a symbolic link using `IoCreateSymbolicLink`, providing the symbolic name "`\DosDevices\RTCore64`" to make the device accessible in the `Global??` directory.

Following this initialization, the driver initializes the Driver Object with two key functions:

1. **Driver Unload Function**: This function handles the unloading of the driver.

2. **Dispatch Routine**: This routine supports the `IRP_MJ_CREATE`, `IRP_MJ_CLOSE`, and `IRP_MJ_DEVICE_CONTROL` requests.

Upon successful completion of these initialization steps, the driver returns `STATUS_SUCCESS`.

## `DriverUnload (sub_1000)`

The driver deletes the symbolic link using the `IoDeleteSymbolicLink` function and then removes the device using `IoDeleteDevice`, passing the device object obtained from the Driver Object.

## `VerifyPCIConfiguration (sub_1420)`


```c++
/*
Params :
port : I/O port
*/
bool __fastcall VerifyPCIConfiguration(int port)
```


If the I/O port specified is not for PCI data transfer, return true. 

Otherwise, read the PCI configuration register and check if it is writable. If it is not writable, return false; otherwise, return true.

## `bValidPhyRange (sub_1040)`


```c++
/*
Params:

BaseAddr : Base Physical address
numberOfBytes : Number of bytes 
minAddr : Minimum address 
maxSize : Maximum size 
*/

bool __fastcall bValidPhyRange(DWORD64 BaseAddr, DWORD64 numberOfBytes, unsigned int minAddr, int maxBytes)
```


Simply verify the range of the physical address and return true if it is in a valid range.


```c++
if(BaseAddr >= minAddr && BaseAddr + bytes <= minAddr + â€¬maxBytes )
	return true
else return false
```

## `bValidPhy (sub_1060)` 

```c++
/*
Params:

BaseAddr : Base Physical address
numberOfBytes : Number of bytes 
busInf: Pointer to a busInf structure holding bus address information
*/

bool __fastcall bValidPhy(DWORD64 BaseAddr, DWORD64 numberOfBytes, BusInf *busInf)
```


Initially, it invokes the function `bValidPhyRange` to verify the validity of the provided physical address range. If `bValidPhyRange` returns true, the process concludes and returns `true`. I

![Pasted image 20240513154559](https://github.com/1X14720f130x/CVE-2019-1609/assets/106280667/0c887d3b-e3ac-4ce9-bae5-461ddc3352ca)


 it utilizes the `busInf` parameter to retrieve information about the physical address and then employs its members in a call to `HalGetBusDataByOffset`.

The `busInf` is a pointer to structure like : 

```c++
#pragma pack(push, 1)
struct BusInf
{
	ULONG busNumber;
	ULONG slotNumber_0;
	ULONG slotNumber_1;
	ULONG offset;
	DWORD len;
	PVOID buffer;
};
#pragma pack(pop)
```

The next verification could be simplified as : 

```c++
if (busInf->offset > 5) return FALSE;
```

Then it call `HalGetBusDataByOffset` using : 

```c++
 HalGetBusDataByOffset( PCIConfiguration, busInf->busNumber, busInf->slotNumber_0 & 0x1F | (0x20 * (busInf->slotNumber_1 & 7)), Buffer, 4 * busInf->offset + 0x10, 4),
```

It then verify the `buffer` initiated by `HalGetBusDataByOffset` : 

```c++
if (Buffer[0] == -1 || Buffer[0] == 0 || Buffer[0] % 2 != 0) return false
```

It then verify the range calling `bValidPhyRange` like 

```c++
return bValidPhyRange(PhyBusAddress, NbrBytes, Buffer[0] & 0xFFFFFF00, 0x1000000);
```

depending on the result it will return `false` or `true`. 

## `MapPhysical (sub_1120)`

This is the **function declaration** : 

```c++
/*
inlen => User Input Len (IoStackLocation->Parameters.DeviceIoControl.InputBufferLength)
outLen => User ouput Len Parameters.DeviceIoControl.OutputBufferLength
*/
NTSTATUS __fastcall MapPhysical(PDEVICE_OBJECT deviceObject, RTCore_1 *systemBuffer, DWORD inLen, DWORD outLen)
```

The `systemBuffer` can be decompiled as a structure : 

```c++
#pragma pack(push, 1)
struct RTCore_MapProc

{

	PVOID baseAddress; // 0x00
	DWORD numberOfBytes; // 0x08
	BusInf* busInf; // 0x0C ( Not used )
	DWORD64 _a; // 0x14 ( Not used )
	DWORD _b; // 0x1C ( Not used )

};
#pragma pack(pop)
```

Initially, it verifies the validity of our physical address (`baseAddress`) by invoking `bValidPhy`. If validation fails, it returns `STATUS_UNSUCCESSFUL`.

It's feasible to provide only the `baseAddress` and `numberOfBytes`, provided that we prepare an `8-byte` buffer to hold the result.

Next, it establishes a handle to the section object `\\Device\\PhysicalMemory` via `ZwOpenSection`.

```c++

// Initialization of object attributes 
  RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");// section object
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;


// Segment all access to physical memory
ZwOpenSection(&SectionHandle, SEGMENT_ALL_ACCESS, &ObjectAttributes);
```

 If the call succeeds, it invokes `ObReferenceObjectByHandle`, passing the resulting `SectionHandle`, to perform access validation.

```c++
// Valide the handle to the section \\Device\\PhysicalMemory with the desired access right
ObReferenceObjectByHandle(SectionHandle, SEGMENT_ALL_ACCESS, 0i64, 0, &Object, 0i64);
```

If validation is successful, it invokes `HalTranslateBusAddress` to ensure that physical addresses are in a valid format. When providing a system physical address to `HalTranslateBusAddress`, it likely returns the same address without performing any translation, as the address is already in the correct format for direct utilization by the memory manager.

```c++
// For BaseAddr
HalTranslateBusAddress(Isa, 0, baseStartAddr, &MAddrSpace1, &TphyBase);

// For BaseAddr + Bytes => End Addr
HalTranslateBusAddress(Isa, 0, EndAddr, &MAddrSpace0, &TEndAddr);
```

These are the subsequent steps: it calls `ZwMapViewOfSection` to map a view of the section, specifying:

- Section offset as : `TphyBase`
- Win32 protect : `PAGE_READWRITE | PAGE_NOCACHE`
- View size equal to `TEndAddr - TphyBase

It then write the `mapped virutal address` directly in the `systembuffer` into `baseAddress` : 

```c++
systemBuffer->baseAddress = virtualAddr
```

then it close the `section handle` using `ZwClose`

# `Dispatch rountine`

It supports a total of 18 IOCTLs ranging from `0x80002000` to `0x80002054`.

Each IOCTL is managed within the main switch statement.

## `IRP_MJ_CLOSE/CREATE`

RTCore simply returns `STATUS_SUCCESS` and calls `IofCompleteRequest(irp, 0)`, indicating that the driver has finished all processing for the given I/O and is returning the IRP to the I/O manager.

This allows a user-mode program to open/close the handle to the driver, enabling further communication.

## `IOCTL_MAP_PHYSICAL_SET (0x80002000)`

The driver maps physical addresses to virtual addresses.

It invokes `MapPhysical` to execute this logic.


![Pasted image 20240513161337](https://github.com/1X14720f130x/CVE-2019-1609/assets/106280667/27f3fa0e-ad42-4295-abce-db0dca456299)

Depending on the result of `MapPhysical`, it returns `STATUS_INVALID_PARAMETER` or `STATUS_SUCCESS`, provided that the virtual address (8 bytes) is stored in `systemBuffer->baseAddress`.

## `IOCTL_UNMAP_PHYSICAL_SET (0x80002004)`

To **unmap** previously mapped physical addresses that were mapped using a `section object`.

![Pasted image 20240513184242](https://github.com/1X14720f130x/CVE-2019-1609/assets/106280667/f8347961-2d55-47dd-b65c-0d7672cb6360)


if the user provides the address to unmap, the driver directly calls `ZwUnmapViewOfSection` to execute the task.

## `IOCTL_READ_IO_PORT_<SIZE>_SET 0x80002008-80002010`


The driver reads the I/O port using the `in` instruction and directly stores the result of size `<size>` in `val`.

The system buffer could be interpreted using this structure:

```c++
struct RTCore_5
{
	DWORD port;
	DWORD val;
}
```

## `IOCTL_WRITE_IO_PORT_<SIZE>_SET 0x80002014-8000201C`


Write the value `val` of size `<size>` to the I/O port using the `out` instruction.

Before writing to the I/O port, it calls `VerifyPCIConfiguration` to ensure that if the selected I/O port is PCI and if this is the case, it make sure it can write to.

The system buffer could be interpreted using this structure:

```c++
struct RTCore_5
{
	DWORD port;
	DWORD val;
}
```


## `IOCTL_INIT_DATA_SET (0x80002028)`

Initialize the user input. 

The `system buffer` could be interpreted using this structure : 

```c++
struct RTCore_3
{
	DWORD a;
	DWORD b;
}
```

It will initialize `a` to `1` and `b` to `8`. 

## `IOCTL_UNK_UPDATE_VAL (0x8000202C)`

Update `dword_3054` depending on the `user input`

The `system buffer` could be interpreted using this structure : 

```c++
struct RTCore_3
{
	DWORD a;
	DWORD b;
}
```

The **update** could be **interpreted** as follow : 

```c++
offset = (a != 0x80000000) ? a : dword_3054
dword_3054 = b + offset
```

## `IOCTL_READ_MSR_SET (0x80002030)`


Read the value from a **model-specific register** (`MSR`)

The `system buffer` could be interpreted using this structure : 

```c++
struct RTCore_MSR // For read/write to MSR
{
	DWORD reg; // 0x00
	DWORD hightVal; // 0x04
	DWORD lowVal; // 0x08
}; // 0x0C
```

It read the `msr` using `rdmsr` of specified `reg` and store the `64 bytes` result in `hightVal:lowVal`

## `IOCTL_WRITE_MSR_SET (0x80002034)`

Write `value` into  the **model-specific register** (`MSR`) 

The `system buffer` could be interpreted using this structure : 

```c++
struct RTCore_MSR // For read/write to MSR
{
	DWORD reg; // 0x00
	DWORD hightVal; // 0x04
	DWORD lowVal; // 0x08
}; // 0x0C
```

It write the `msr` using `wrmsr` of the value specified into `hightVal:lowVal` in  `reg`


## `IOCTL_MAP_PHYSICAL_SYSTEM_SET (0x80002040)`

**Map** `physical addresses` to `virtual addresses` using `MmMapIoSpace`


The `system buffer` could be interpreted using this structure : 

```c++
struct RTCore_MapSystem // For mapping (MmMapIoSpace)
{
	PVOID baseAddress; // 0x00
	PVOID virtualAddr;  // 0x08
	DWORD numberOfBytes;  // 0x10
	DWORD64 e;  // 0x18
	LPVOID busInf;  // 0x20
	DWORD64 g;  // 0x28
};  // 0x30
```

Similar to `IOCTL_MAP_PHYSICAL_SET`, but instead of utilizing the `\\Device\\PhysicalMemory` section object, it directly maps physical addresses to virtual addresses using `MmMapIoSpace`.

If successful, it returns the virtual address in `virtualAddr` field.


## `IOCTL_UNMAP_PHYSICAL_SYSTEM_SET (0x80002044)`

Unmap previously mapped physical addresses that were mapped using `MmMapIoSpace`.

The `system buffer` could be interpreted using this structure : 

```c++
struct RTCore_MapSystem // For mapping (MmMapIoSpace)
{
	PVOID baseAddress; // 0x00
	PVOID virtualAddr;  // 0x08
	DWORD numberOfBytes;  // 0x10
	DWORD64 e;  // 0x18
	LPVOID busInf;  // 0x20
	DWORD64 g;  // 0x28
};  // 0x30
```

This is the following call to `MmUnmapIoSpace`  :

```c++
MmUnmapIoSpace(RTCore_0->baseAddress, RTCore_0->dwNumberOfBytes);
```


## `IOCTL_READ_SET (0x80002048)`

Read a byte, word, or dword of a specified address.

The `system buffer` could be interpreted using this structure : 

```c++
#pragma pack(push, 1)
struct RTCore_Memory // For Read/Write memory operations
{
	DWORD64 _pad0; // 0x00
	LPVOID addr; // 0x08
	DWORD _pad1; // 0x10
	DWORD offset; // 0x14
	DWORD size; // 0x18
	DWORD val; // 0x1C
	DWORD _pad2; // 0x20
	DWORD64 _pad3; // 0x24
	DWORD _pad4; // 0x2C
}; // 0x30
#pragma pack(pop)
```

It reads the value at `addr + offset` and stores the value of the specified size in  `val`.

The specified size could be 1, 2, or 4 bytes.


## `IOCTL_WRITE_SET (0x8000204C)`


Write a byte, word, or dword value at a specified address.

The `system buffer` could be interpreted using this structure : 

```c++
#pragma pack(push, 1)
struct RTCore_Memory // For Read/Write memory operations
{
	DWORD64 _pad0; // 0x00
	LPVOID addr; // 0x08
	DWORD _pad1; // 0x10
	DWORD offset; // 0x14
	DWORD size; // 0x18
	DWORD val; // 0x1C
	DWORD _pad2; // 0x20
	DWORD64 _pad3; // 0x24
	DWORD _pad4; // 0x2C
}; // 0x30
#pragma pack(pop)
```
It writes the value of the specified size at `addr + offset`.

The specified size could be 1, 2, or 4 bytes.

## `IOCTL_GET_PCI_CONF_SET (0x80002050)`

Retrieve the PCI config space information for the specified data provided by the user.

The `system buffer` could be interpreted using this structure : 

```c++
#pragma pack(push, 1)
struct BusInf
{
	ULONG busNumber;
	ULONG slotNumber_0;
	ULONG slotNumber_1;
	ULONG offset;
	DWORD len;
	PVOID buffer;
};
#pragma pack(pop)
```

It directly calls `HalGetBusDataByOffset`. 

```c++
HalGetBusDataByOffset("PCIConfiguration",busNumber, slotNumber_0 & 0x1F | (32 * slotNumber_1 & 7),buffer, offset, len)
```

The buffer contains the PCI config space.

## `IOCTL_SET_PCI_CONF_SET (0x80002050)`

Set the PCI config space information using the buffer provided by the user.

The `system buffer` could be interpreted using this structure : 

```c++
#pragma pack(push, 1)
struct BusInf
{
	ULONG busNumber;
	ULONG slotNumber_0;
	ULONG slotNumber_1;
	ULONG offset;
	DWORD len;
	PVOID buffer;
};
#pragma pack(pop)
```

It directly calls `HalSetBusDataByOffset`  : 

```c++
HalSetBusDataByOffset("PCIConfiguration", busNumber, slotNumber_0 & 0x1F | (32 * slotNumber_1 & 7),buffer, offset, len)
```

The PCI config space is set by the provided buffer.


# `Overview`

The driver `RTCore` offers several privileged features, including:

- Read/Write memory
- Read/Write I/O Ports
- Read/Write MSR
- Read/Write PCI configurations
- Map physical addresses
